/* This file was generated by SableCC (http://www.sablecc.org/). */

package fr.umlv.symphonie.data.formula.parser;

import java.io.BufferedInputStream;
import java.io.DataInputStream;
import java.io.IOException;
import java.util.LinkedList;
import java.util.List;
import java.util.ListIterator;

import fr.umlv.symphonie.data.formula.analysis.Analysis;
import fr.umlv.symphonie.data.formula.analysis.AnalysisAdapter;
import fr.umlv.symphonie.data.formula.lexer.Lexer;
import fr.umlv.symphonie.data.formula.lexer.LexerException;
import fr.umlv.symphonie.data.formula.node.AAdditionAdditiveExpression;
import fr.umlv.symphonie.data.formula.node.ABooleanExpression;
import fr.umlv.symphonie.data.formula.node.ACellBlockExpression;
import fr.umlv.symphonie.data.formula.node.ACellEvaluatedExpression;
import fr.umlv.symphonie.data.formula.node.AComparativeLogicalAndExpression;
import fr.umlv.symphonie.data.formula.node.ADataBlockExpression;
import fr.umlv.symphonie.data.formula.node.ADivisionMultiplicativeExpression;
import fr.umlv.symphonie.data.formula.node.ADoubleLiteralExpression;
import fr.umlv.symphonie.data.formula.node.AEqualityComparativeExpression;
import fr.umlv.symphonie.data.formula.node.AEqualsEqualityExpression;
import fr.umlv.symphonie.data.formula.node.AEvaluatedNumericExpression;
import fr.umlv.symphonie.data.formula.node.AFunctionEvaluatedExpression;
import fr.umlv.symphonie.data.formula.node.AGreaterThanOrEqualsRelationalExpression;
import fr.umlv.symphonie.data.formula.node.AGreaterThanRelationalExpression;
import fr.umlv.symphonie.data.formula.node.AIdentifiers;
import fr.umlv.symphonie.data.formula.node.AIntegerLiteralExpression;
import fr.umlv.symphonie.data.formula.node.ALessThanOrEqualsRelationalExpression;
import fr.umlv.symphonie.data.formula.node.ALessThanRelationalExpression;
import fr.umlv.symphonie.data.formula.node.ALiteralComparativeExpression;
import fr.umlv.symphonie.data.formula.node.ALiteralNumericExpression;
import fr.umlv.symphonie.data.formula.node.ALogicalAndLogicalAndExpression;
import fr.umlv.symphonie.data.formula.node.ALogicalAndLogicalOrExpression;
import fr.umlv.symphonie.data.formula.node.ALogicalOrLogicalOrExpression;
import fr.umlv.symphonie.data.formula.node.AMinusUnaryExpression;
import fr.umlv.symphonie.data.formula.node.AModulusMultiplicativeExpression;
import fr.umlv.symphonie.data.formula.node.AMultiplicationMultiplicativeExpression;
import fr.umlv.symphonie.data.formula.node.AMultiplicativeAdditiveExpression;
import fr.umlv.symphonie.data.formula.node.ANotEqualsEqualityExpression;
import fr.umlv.symphonie.data.formula.node.ANumericExpression;
import fr.umlv.symphonie.data.formula.node.ANumericUnaryExpression;
import fr.umlv.symphonie.data.formula.node.AParenthethicComparativeExpression;
import fr.umlv.symphonie.data.formula.node.AParentheticNumericExpression;
import fr.umlv.symphonie.data.formula.node.ARelationalComparativeExpression;
import fr.umlv.symphonie.data.formula.node.ASeparatorSuffixedId;
import fr.umlv.symphonie.data.formula.node.ASubstractionAdditiveExpression;
import fr.umlv.symphonie.data.formula.node.AUnaryMultiplicativeExpression;
import fr.umlv.symphonie.data.formula.node.EOF;
import fr.umlv.symphonie.data.formula.node.Node;
import fr.umlv.symphonie.data.formula.node.NodeCast;
import fr.umlv.symphonie.data.formula.node.PAdditiveExpression;
import fr.umlv.symphonie.data.formula.node.PBlockExpression;
import fr.umlv.symphonie.data.formula.node.PComparativeExpression;
import fr.umlv.symphonie.data.formula.node.PEqualityExpression;
import fr.umlv.symphonie.data.formula.node.PEvaluatedExpression;
import fr.umlv.symphonie.data.formula.node.PExpression;
import fr.umlv.symphonie.data.formula.node.PIdentifiers;
import fr.umlv.symphonie.data.formula.node.PLiteralExpression;
import fr.umlv.symphonie.data.formula.node.PLogicalAndExpression;
import fr.umlv.symphonie.data.formula.node.PLogicalOrExpression;
import fr.umlv.symphonie.data.formula.node.PMultiplicativeExpression;
import fr.umlv.symphonie.data.formula.node.PNumericExpression;
import fr.umlv.symphonie.data.formula.node.PRelationalExpression;
import fr.umlv.symphonie.data.formula.node.PSeparatorSuffixedId;
import fr.umlv.symphonie.data.formula.node.PUnaryExpression;
import fr.umlv.symphonie.data.formula.node.Start;
import fr.umlv.symphonie.data.formula.node.Switchable;
import fr.umlv.symphonie.data.formula.node.TAdditionOperator;
import fr.umlv.symphonie.data.formula.node.TBlockEnd;
import fr.umlv.symphonie.data.formula.node.TBlockPrefix;
import fr.umlv.symphonie.data.formula.node.TBlockStart;
import fr.umlv.symphonie.data.formula.node.TBooleanLiteral;
import fr.umlv.symphonie.data.formula.node.TDivisionOperator;
import fr.umlv.symphonie.data.formula.node.TDoubleLiteral;
import fr.umlv.symphonie.data.formula.node.TEquals;
import fr.umlv.symphonie.data.formula.node.TFuncId;
import fr.umlv.symphonie.data.formula.node.TGreaterThan;
import fr.umlv.symphonie.data.formula.node.TGreaterThanOrEquals;
import fr.umlv.symphonie.data.formula.node.TIdSeparator;
import fr.umlv.symphonie.data.formula.node.TIdentifier;
import fr.umlv.symphonie.data.formula.node.TIntegerLiteral;
import fr.umlv.symphonie.data.formula.node.TLeftParenthesis;
import fr.umlv.symphonie.data.formula.node.TLessThan;
import fr.umlv.symphonie.data.formula.node.TLessThanOrEquals;
import fr.umlv.symphonie.data.formula.node.TLogicalAndOperator;
import fr.umlv.symphonie.data.formula.node.TLogicalOrOperator;
import fr.umlv.symphonie.data.formula.node.TModulusOperator;
import fr.umlv.symphonie.data.formula.node.TMultiplicationOperator;
import fr.umlv.symphonie.data.formula.node.TNotEquals;
import fr.umlv.symphonie.data.formula.node.TRightParenthesis;
import fr.umlv.symphonie.data.formula.node.TSubstractionOperator;
import fr.umlv.symphonie.data.formula.node.Token;
import fr.umlv.symphonie.data.formula.node.TypedLinkedList;
import fr.umlv.symphonie.data.formula.node.X1PSeparatorSuffixedId;
import fr.umlv.symphonie.data.formula.node.X2PSeparatorSuffixedId;
import fr.umlv.symphonie.data.formula.node.XPSeparatorSuffixedId;

public class Parser {

  public final Analysis ignoredTokens = new AnalysisAdapter();

  protected Node node;

  private final Lexer lexer;
  private final ListIterator stack = new LinkedList().listIterator();
  private int last_shift;
  private int last_pos;
  private int last_line;
  private Token last_token;
  private final TokenIndex converter = new TokenIndex();
  private final int[] action = new int[2];

  private final static int SHIFT = 0;
  private final static int REDUCE = 1;
  private final static int ACCEPT = 2;
  private final static int ERROR = 3;

  protected void filter() throws ParserException, LexerException, IOException {
  }

  public Parser(Lexer lexer) {
    this.lexer = lexer;

    if (actionTable == null) {
      try {
        DataInputStream s = new DataInputStream(new BufferedInputStream(
            Parser.class.getResourceAsStream("parser.dat")));

        // read actionTable
        int length = s.readInt();
        actionTable = new int[length][][];
        for (int i = 0; i < actionTable.length; i++) {
          length = s.readInt();
          actionTable[i] = new int[length][3];
          for (int j = 0; j < actionTable[i].length; j++) {
            for (int k = 0; k < 3; k++) {
              actionTable[i][j][k] = s.readInt();
            }
          }
        }

        // read gotoTable
        length = s.readInt();
        gotoTable = new int[length][][];
        for (int i = 0; i < gotoTable.length; i++) {
          length = s.readInt();
          gotoTable[i] = new int[length][2];
          for (int j = 0; j < gotoTable[i].length; j++) {
            for (int k = 0; k < 2; k++) {
              gotoTable[i][j][k] = s.readInt();
            }
          }
        }

        // read errorMessages
        length = s.readInt();
        errorMessages = new String[length];
        for (int i = 0; i < errorMessages.length; i++) {
          length = s.readInt();
          StringBuffer buffer = new StringBuffer();

          for (int j = 0; j < length; j++) {
            buffer.append(s.readChar());
          }
          errorMessages[i] = buffer.toString();
        }

        // read errors
        length = s.readInt();
        errors = new int[length];
        for (int i = 0; i < errors.length; i++) {
          errors[i] = s.readInt();
        }

        s.close();
      } catch (Exception e) {
        throw new RuntimeException(
            "The file \"parser.dat\" is either missing or corrupted.");
      }
    }
  }

  private int goTo(int index) {
    int state = state();
    int low = 1;
    int high = gotoTable[index].length - 1;
    int value = gotoTable[index][0][1];

    while (low <= high) {
      int middle = (low + high) / 2;

      if (state < gotoTable[index][middle][0]) {
        high = middle - 1;
      } else if (state > gotoTable[index][middle][0]) {
        low = middle + 1;
      } else {
        value = gotoTable[index][middle][1];
        break;
      }
    }

    return value;
  }

  private void push(int state, Node node, boolean filter)
      throws ParserException, LexerException, IOException {
    this.node = node;

    if (filter) {
      filter();
    }

    if (!stack.hasNext()) {
      stack.add(new State(state, this.node));
      return;
    }

    State s = (State) stack.next();
    s.state = state;
    s.node = this.node;
  }

  private int state() {
    State s = (State) stack.previous();
    stack.next();
    return s.state;
  }

  private Node pop() {
    return (Node) ((State) stack.previous()).node;
  }

  private int index(Switchable token) {
    converter.index = -1;
    token.apply(converter);
    return converter.index;
  }

  public Start parse() throws ParserException, LexerException, IOException {
    push(0, null, false);

    List ign = null;
    while (true) {
      while (index(lexer.peek()) == -1) {
        if (ign == null) {
          ign = new TypedLinkedList(NodeCast.instance);
        }

        ign.add(lexer.next());
      }

      if (ign != null) {
        ignoredTokens.setIn(lexer.peek(), ign);
        ign = null;
      }

      last_pos = lexer.peek().getPos();
      last_line = lexer.peek().getLine();
      last_token = lexer.peek();

      int index = index(lexer.peek());
      action[0] = actionTable[state()][0][1];
      action[1] = actionTable[state()][0][2];

      int low = 1;
      int high = actionTable[state()].length - 1;

      while (low <= high) {
        int middle = (low + high) / 2;

        if (index < actionTable[state()][middle][0]) {
          high = middle - 1;
        } else if (index > actionTable[state()][middle][0]) {
          low = middle + 1;
        } else {
          action[0] = actionTable[state()][middle][1];
          action[1] = actionTable[state()][middle][2];
          break;
        }
      }

      switch (action[0]) {
        case SHIFT:
          push(action[1], lexer.next(), true);
          last_shift = action[1];
          break;
        case REDUCE:
          switch (action[1]) {
            case 0: {
              Node node = new0();
              push(goTo(0), node, true);
            }
              break;
            case 1: {
              Node node = new1();
              push(goTo(0), node, true);
            }
              break;
            case 2: {
              Node node = new2();
              push(goTo(1), node, true);
            }
              break;
            case 3: {
              Node node = new3();
              push(goTo(1), node, true);
            }
              break;
            case 4: {
              Node node = new4();
              push(goTo(1), node, true);
            }
              break;
            case 5: {
              Node node = new5();
              push(goTo(2), node, true);
            }
              break;
            case 6: {
              Node node = new6();
              push(goTo(2), node, true);
            }
              break;
            case 7: {
              Node node = new7();
              push(goTo(2), node, true);
            }
              break;
            case 8: {
              Node node = new8();
              push(goTo(2), node, true);
            }
              break;
            case 9: {
              Node node = new9();
              push(goTo(3), node, true);
            }
              break;
            case 10: {
              Node node = new10();
              push(goTo(3), node, true);
            }
              break;
            case 11: {
              Node node = new11();
              push(goTo(4), node, true);
            }
              break;
            case 12: {
              Node node = new12();
              push(goTo(4), node, true);
            }
              break;
            case 13: {
              Node node = new13();
              push(goTo(4), node, true);
            }
              break;
            case 14: {
              Node node = new14();
              push(goTo(5), node, true);
            }
              break;
            case 15: {
              Node node = new15();
              push(goTo(5), node, true);
            }
              break;
            case 16: {
              Node node = new16();
              push(goTo(6), node, true);
            }
              break;
            case 17: {
              Node node = new17();
              push(goTo(6), node, true);
            }
              break;
            case 18: {
              Node node = new18();
              push(goTo(7), node, true);
            }
              break;
            case 19: {
              Node node = new19();
              push(goTo(7), node, true);
            }
              break;
            case 20: {
              Node node = new20();
              push(goTo(8), node, true);
            }
              break;
            case 21: {
              Node node = new21();
              push(goTo(8), node, true);
            }
              break;
            case 22: {
              Node node = new22();
              push(goTo(15), node, false);
            }
              break;
            case 23: {
              Node node = new23();
              push(goTo(15), node, false);
            }
              break;
            case 24: {
              Node node = new24();
              push(goTo(9), node, true);
            }
              break;
            case 25: {
              Node node = new25();
              push(goTo(10), node, true);
            }
              break;
            case 26: {
              Node node = new26();
              push(goTo(10), node, true);
            }
              break;
            case 27: {
              Node node = new27();
              push(goTo(11), node, true);
            }
              break;
            case 28: {
              Node node = new28();
              push(goTo(11), node, true);
            }
              break;
            case 29: {
              Node node = new29();
              push(goTo(12), node, true);
            }
              break;
            case 30: {
              Node node = new30();
              push(goTo(12), node, true);
            }
              break;
            case 31: {
              Node node = new31();
              push(goTo(12), node, true);
            }
              break;
            case 32: {
              Node node = new32();
              push(goTo(12), node, true);
            }
              break;
            case 33: {
              Node node = new33();
              push(goTo(13), node, true);
            }
              break;
            case 34: {
              Node node = new34();
              push(goTo(13), node, true);
            }
              break;
            case 35: {
              Node node = new35();
              push(goTo(14), node, true);
            }
              break;
            case 36: {
              Node node = new36();
              push(goTo(14), node, true);
            }
              break;
            case 37: {
              Node node = new37();
              push(goTo(14), node, true);
            }
              break;
            case 38: {
              Node node = new38();
              push(goTo(14), node, true);
            }
              break;
          }
          break;
        case ACCEPT: {
          EOF node2 = (EOF) lexer.next();
          PExpression node1 = (PExpression) pop();
          Start node = new Start(node1, node2);
          return node;
        }
        case ERROR:
          throw new ParserException(last_token, "[" + last_line + ","
              + last_pos + "] " + errorMessages[errors[action[1]]]);
      }
    }
  }

  Node new0() {
    PAdditiveExpression node1 = (PAdditiveExpression) pop();
    ANumericExpression node = new ANumericExpression(node1);
    return node;
  }

  Node new1() {
    PLogicalOrExpression node1 = (PLogicalOrExpression) pop();
    ABooleanExpression node = new ABooleanExpression(node1);
    return node;
  }

  Node new2() {
    PMultiplicativeExpression node1 = (PMultiplicativeExpression) pop();
    AMultiplicativeAdditiveExpression node = new AMultiplicativeAdditiveExpression(
        node1);
    return node;
  }

  Node new3() {
    PMultiplicativeExpression node3 = (PMultiplicativeExpression) pop();
    TAdditionOperator node2 = (TAdditionOperator) pop();
    PAdditiveExpression node1 = (PAdditiveExpression) pop();
    AAdditionAdditiveExpression node = new AAdditionAdditiveExpression(node1,
        node2, node3);
    return node;
  }

  Node new4() {
    PMultiplicativeExpression node3 = (PMultiplicativeExpression) pop();
    TSubstractionOperator node2 = (TSubstractionOperator) pop();
    PAdditiveExpression node1 = (PAdditiveExpression) pop();
    ASubstractionAdditiveExpression node = new ASubstractionAdditiveExpression(
        node1, node2, node3);
    return node;
  }

  Node new5() {
    PUnaryExpression node1 = (PUnaryExpression) pop();
    AUnaryMultiplicativeExpression node = new AUnaryMultiplicativeExpression(
        node1);
    return node;
  }

  Node new6() {
    PUnaryExpression node3 = (PUnaryExpression) pop();
    TMultiplicationOperator node2 = (TMultiplicationOperator) pop();
    PMultiplicativeExpression node1 = (PMultiplicativeExpression) pop();
    AMultiplicationMultiplicativeExpression node = new AMultiplicationMultiplicativeExpression(
        node1, node2, node3);
    return node;
  }

  Node new7() {
    PUnaryExpression node3 = (PUnaryExpression) pop();
    TDivisionOperator node2 = (TDivisionOperator) pop();
    PMultiplicativeExpression node1 = (PMultiplicativeExpression) pop();
    ADivisionMultiplicativeExpression node = new ADivisionMultiplicativeExpression(
        node1, node2, node3);
    return node;
  }

  Node new8() {
    PUnaryExpression node3 = (PUnaryExpression) pop();
    TModulusOperator node2 = (TModulusOperator) pop();
    PMultiplicativeExpression node1 = (PMultiplicativeExpression) pop();
    AModulusMultiplicativeExpression node = new AModulusMultiplicativeExpression(
        node1, node2, node3);
    return node;
  }

  Node new9() {
    PNumericExpression node1 = (PNumericExpression) pop();
    ANumericUnaryExpression node = new ANumericUnaryExpression(node1);
    return node;
  }

  Node new10() {
    PNumericExpression node2 = (PNumericExpression) pop();
    TSubstractionOperator node1 = (TSubstractionOperator) pop();
    AMinusUnaryExpression node = new AMinusUnaryExpression(node1, node2);
    return node;
  }

  Node new11() {
    PLiteralExpression node1 = (PLiteralExpression) pop();
    ALiteralNumericExpression node = new ALiteralNumericExpression(node1);
    return node;
  }

  Node new12() {
    PEvaluatedExpression node1 = (PEvaluatedExpression) pop();
    AEvaluatedNumericExpression node = new AEvaluatedNumericExpression(node1);
    return node;
  }

  Node new13() {
    TRightParenthesis node3 = (TRightParenthesis) pop();
    PAdditiveExpression node2 = (PAdditiveExpression) pop();
    TLeftParenthesis node1 = (TLeftParenthesis) pop();
    AParentheticNumericExpression node = new AParentheticNumericExpression(
        node1, node2, node3);
    return node;
  }

  Node new14() {
    TIntegerLiteral node1 = (TIntegerLiteral) pop();
    AIntegerLiteralExpression node = new AIntegerLiteralExpression(node1);
    return node;
  }

  Node new15() {
    TDoubleLiteral node1 = (TDoubleLiteral) pop();
    ADoubleLiteralExpression node = new ADoubleLiteralExpression(node1);
    return node;
  }

  Node new16() {
    TRightParenthesis node4 = (TRightParenthesis) pop();
    PBlockExpression node3 = (PBlockExpression) pop();
    TLeftParenthesis node2 = (TLeftParenthesis) pop();
    TFuncId node1 = (TFuncId) pop();
    AFunctionEvaluatedExpression node = new AFunctionEvaluatedExpression(node1,
        node2, node3, node4);
    return node;
  }

  Node new17() {
    TBlockEnd node3 = (TBlockEnd) pop();
    TIdentifier node2 = (TIdentifier) pop();
    TBlockStart node1 = (TBlockStart) pop();
    ACellEvaluatedExpression node = new ACellEvaluatedExpression(node1, node2,
        node3);
    return node;
  }

  Node new18() {
    TFuncId node2 = (TFuncId) pop();
    TBlockPrefix node1 = (TBlockPrefix) pop();
    ADataBlockExpression node = new ADataBlockExpression(node1, node2);
    return node;
  }

  Node new19() {
    TBlockEnd node3 = (TBlockEnd) pop();
    PIdentifiers node2 = (PIdentifiers) pop();
    TBlockStart node1 = (TBlockStart) pop();
    ACellBlockExpression node = new ACellBlockExpression(node1, node2, node3);
    return node;
  }

  Node new20() {
    TIdentifier node2 = (TIdentifier) pop();
    XPSeparatorSuffixedId node1 = null;
    AIdentifiers node = new AIdentifiers(node1, node2);
    return node;
  }

  Node new21() {
    TIdentifier node2 = (TIdentifier) pop();
    XPSeparatorSuffixedId node1 = (XPSeparatorSuffixedId) pop();
    AIdentifiers node = new AIdentifiers(node1, node2);
    return node;
  }

  Node new22() {
    PSeparatorSuffixedId node2 = (PSeparatorSuffixedId) pop();
    XPSeparatorSuffixedId node1 = (XPSeparatorSuffixedId) pop();
    X1PSeparatorSuffixedId node = new X1PSeparatorSuffixedId(node1, node2);
    return node;
  }

  Node new23() {
    PSeparatorSuffixedId node1 = (PSeparatorSuffixedId) pop();
    X2PSeparatorSuffixedId node = new X2PSeparatorSuffixedId(node1);
    return node;
  }

  Node new24() {
    TIdSeparator node2 = (TIdSeparator) pop();
    TIdentifier node1 = (TIdentifier) pop();
    ASeparatorSuffixedId node = new ASeparatorSuffixedId(node1, node2);
    return node;
  }

  Node new25() {
    PLogicalAndExpression node1 = (PLogicalAndExpression) pop();
    ALogicalAndLogicalOrExpression node = new ALogicalAndLogicalOrExpression(
        node1);
    return node;
  }

  Node new26() {
    PLogicalAndExpression node3 = (PLogicalAndExpression) pop();
    TLogicalOrOperator node2 = (TLogicalOrOperator) pop();
    PLogicalOrExpression node1 = (PLogicalOrExpression) pop();
    ALogicalOrLogicalOrExpression node = new ALogicalOrLogicalOrExpression(
        node1, node2, node3);
    return node;
  }

  Node new27() {
    PComparativeExpression node1 = (PComparativeExpression) pop();
    AComparativeLogicalAndExpression node = new AComparativeLogicalAndExpression(
        node1);
    return node;
  }

  Node new28() {
    PComparativeExpression node3 = (PComparativeExpression) pop();
    TLogicalAndOperator node2 = (TLogicalAndOperator) pop();
    PLogicalAndExpression node1 = (PLogicalAndExpression) pop();
    ALogicalAndLogicalAndExpression node = new ALogicalAndLogicalAndExpression(
        node1, node2, node3);
    return node;
  }

  Node new29() {
    PEqualityExpression node1 = (PEqualityExpression) pop();
    AEqualityComparativeExpression node = new AEqualityComparativeExpression(
        node1);
    return node;
  }

  Node new30() {
    PRelationalExpression node1 = (PRelationalExpression) pop();
    ARelationalComparativeExpression node = new ARelationalComparativeExpression(
        node1);
    return node;
  }

  Node new31() {
    TBooleanLiteral node1 = (TBooleanLiteral) pop();
    ALiteralComparativeExpression node = new ALiteralComparativeExpression(
        node1);
    return node;
  }

  Node new32() {
    TRightParenthesis node3 = (TRightParenthesis) pop();
    PLogicalOrExpression node2 = (PLogicalOrExpression) pop();
    TLeftParenthesis node1 = (TLeftParenthesis) pop();
    AParenthethicComparativeExpression node = new AParenthethicComparativeExpression(
        node1, node2, node3);
    return node;
  }

  Node new33() {
    PAdditiveExpression node3 = (PAdditiveExpression) pop();
    TEquals node2 = (TEquals) pop();
    PAdditiveExpression node1 = (PAdditiveExpression) pop();
    AEqualsEqualityExpression node = new AEqualsEqualityExpression(node1,
        node2, node3);
    return node;
  }

  Node new34() {
    PAdditiveExpression node3 = (PAdditiveExpression) pop();
    TNotEquals node2 = (TNotEquals) pop();
    PAdditiveExpression node1 = (PAdditiveExpression) pop();
    ANotEqualsEqualityExpression node = new ANotEqualsEqualityExpression(node1,
        node2, node3);
    return node;
  }

  Node new35() {
    PAdditiveExpression node3 = (PAdditiveExpression) pop();
    TLessThan node2 = (TLessThan) pop();
    PAdditiveExpression node1 = (PAdditiveExpression) pop();
    ALessThanRelationalExpression node = new ALessThanRelationalExpression(
        node1, node2, node3);
    return node;
  }

  Node new36() {
    PAdditiveExpression node3 = (PAdditiveExpression) pop();
    TLessThanOrEquals node2 = (TLessThanOrEquals) pop();
    PAdditiveExpression node1 = (PAdditiveExpression) pop();
    ALessThanOrEqualsRelationalExpression node = new ALessThanOrEqualsRelationalExpression(
        node1, node2, node3);
    return node;
  }

  Node new37() {
    PAdditiveExpression node3 = (PAdditiveExpression) pop();
    TGreaterThan node2 = (TGreaterThan) pop();
    PAdditiveExpression node1 = (PAdditiveExpression) pop();
    AGreaterThanRelationalExpression node = new AGreaterThanRelationalExpression(
        node1, node2, node3);
    return node;
  }

  Node new38() {
    PAdditiveExpression node3 = (PAdditiveExpression) pop();
    TGreaterThanOrEquals node2 = (TGreaterThanOrEquals) pop();
    PAdditiveExpression node1 = (PAdditiveExpression) pop();
    AGreaterThanOrEqualsRelationalExpression node = new AGreaterThanOrEqualsRelationalExpression(
        node1, node2, node3);
    return node;
  }

  private static int[][][] actionTable;
  /*
   * { {{-1, ERROR, 0}, {1, SHIFT, 1}, {5, SHIFT, 2}, {6, SHIFT, 3}, {7, SHIFT,
   * 4}, {8, SHIFT, 5}, {14, SHIFT, 6}, {23, SHIFT, 7}, }, {{-1, ERROR, 1}, {3,
   * SHIFT, 20}, }, {{-1, REDUCE, 14}, }, {{-1, REDUCE, 15}, }, {{-1, REDUCE,
   * 31}, }, {{-1, ERROR, 5}, {1, SHIFT, 1}, {5, SHIFT, 2}, {6, SHIFT, 3}, {7,
   * SHIFT, 4}, {8, SHIFT, 5}, {14, SHIFT, 6}, {23, SHIFT, 7}, }, {{-1, ERROR,
   * 6}, {1, SHIFT, 1}, {5, SHIFT, 2}, {6, SHIFT, 3}, {8, SHIFT, 23}, {23,
   * SHIFT, 7}, }, {{-1, ERROR, 7}, {8, SHIFT, 25}, }, {{-1, ERROR, 8}, {24,
   * ACCEPT, -1}, }, {{-1, REDUCE, 0}, {13, SHIFT, 26}, {14, SHIFT, 27}, {15,
   * SHIFT, 28}, {16, SHIFT, 29}, {17, SHIFT, 30}, {18, SHIFT, 31}, {19, SHIFT,
   * 32}, {20, SHIFT, 33}, }, {{-1, REDUCE, 2}, {10, SHIFT, 34}, {11, SHIFT,
   * 35}, {12, SHIFT, 36}, }, {{-1, REDUCE, 5}, }, {{-1, REDUCE, 9}, }, {{-1,
   * REDUCE, 11}, }, {{-1, REDUCE, 12}, }, {{-1, REDUCE, 1}, {22, SHIFT, 37}, },
   * {{-1, REDUCE, 25}, {21, SHIFT, 38}, }, {{-1, REDUCE, 27}, }, {{-1, REDUCE,
   * 29}, }, {{-1, REDUCE, 30}, }, {{-1, ERROR, 20}, {2, SHIFT, 39}, }, {{-1,
   * ERROR, 21}, {9, SHIFT, 40}, {13, SHIFT, 26}, {14, SHIFT, 27}, {15, SHIFT,
   * 28}, {16, SHIFT, 29}, {17, SHIFT, 30}, {18, SHIFT, 31}, {19, SHIFT, 32},
   * {20, SHIFT, 33}, }, {{-1, ERROR, 22}, {9, SHIFT, 41}, {22, SHIFT, 37}, },
   * {{-1, ERROR, 23}, {1, SHIFT, 1}, {5, SHIFT, 2}, {6, SHIFT, 3}, {8, SHIFT,
   * 23}, {14, SHIFT, 6}, {23, SHIFT, 7}, }, {{-1, REDUCE, 10}, }, {{-1, ERROR,
   * 25}, {0, SHIFT, 43}, {1, SHIFT, 44}, }, {{-1, ERROR, 26}, {1, SHIFT, 1},
   * {5, SHIFT, 2}, {6, SHIFT, 3}, {8, SHIFT, 23}, {14, SHIFT, 6}, {23, SHIFT,
   * 7}, }, {{-1, ERROR, 27}, {1, SHIFT, 1}, {5, SHIFT, 2}, {6, SHIFT, 3}, {8,
   * SHIFT, 23}, {14, SHIFT, 6}, {23, SHIFT, 7}, }, {{-1, ERROR, 28}, {1, SHIFT,
   * 1}, {5, SHIFT, 2}, {6, SHIFT, 3}, {8, SHIFT, 23}, {14, SHIFT, 6}, {23,
   * SHIFT, 7}, }, {{-1, ERROR, 29}, {1, SHIFT, 1}, {5, SHIFT, 2}, {6, SHIFT,
   * 3}, {8, SHIFT, 23}, {14, SHIFT, 6}, {23, SHIFT, 7}, }, {{-1, ERROR, 30},
   * {1, SHIFT, 1}, {5, SHIFT, 2}, {6, SHIFT, 3}, {8, SHIFT, 23}, {14, SHIFT,
   * 6}, {23, SHIFT, 7}, }, {{-1, ERROR, 31}, {1, SHIFT, 1}, {5, SHIFT, 2}, {6,
   * SHIFT, 3}, {8, SHIFT, 23}, {14, SHIFT, 6}, {23, SHIFT, 7}, }, {{-1, ERROR,
   * 32}, {1, SHIFT, 1}, {5, SHIFT, 2}, {6, SHIFT, 3}, {8, SHIFT, 23}, {14,
   * SHIFT, 6}, {23, SHIFT, 7}, }, {{-1, ERROR, 33}, {1, SHIFT, 1}, {5, SHIFT,
   * 2}, {6, SHIFT, 3}, {8, SHIFT, 23}, {14, SHIFT, 6}, {23, SHIFT, 7}, }, {{-1,
   * ERROR, 34}, {1, SHIFT, 1}, {5, SHIFT, 2}, {6, SHIFT, 3}, {8, SHIFT, 23},
   * {14, SHIFT, 6}, {23, SHIFT, 7}, }, {{-1, ERROR, 35}, {1, SHIFT, 1}, {5,
   * SHIFT, 2}, {6, SHIFT, 3}, {8, SHIFT, 23}, {14, SHIFT, 6}, {23, SHIFT, 7}, },
   * {{-1, ERROR, 36}, {1, SHIFT, 1}, {5, SHIFT, 2}, {6, SHIFT, 3}, {8, SHIFT,
   * 23}, {14, SHIFT, 6}, {23, SHIFT, 7}, }, {{-1, ERROR, 37}, {1, SHIFT, 1},
   * {5, SHIFT, 2}, {6, SHIFT, 3}, {7, SHIFT, 4}, {8, SHIFT, 5}, {14, SHIFT, 6},
   * {23, SHIFT, 7}, }, {{-1, ERROR, 38}, {1, SHIFT, 1}, {5, SHIFT, 2}, {6,
   * SHIFT, 3}, {7, SHIFT, 4}, {8, SHIFT, 5}, {14, SHIFT, 6}, {23, SHIFT, 7}, },
   * {{-1, REDUCE, 17}, }, {{-1, REDUCE, 13}, }, {{-1, REDUCE, 32}, }, {{-1,
   * ERROR, 42}, {9, SHIFT, 40}, {13, SHIFT, 26}, {14, SHIFT, 27}, }, {{-1,
   * ERROR, 43}, {23, SHIFT, 60}, }, {{-1, ERROR, 44}, {3, SHIFT, 61}, }, {{-1,
   * ERROR, 45}, {9, SHIFT, 65}, }, {{-1, REDUCE, 3}, {10, SHIFT, 34}, {11,
   * SHIFT, 35}, {12, SHIFT, 36}, }, {{-1, REDUCE, 4}, {10, SHIFT, 34}, {11,
   * SHIFT, 35}, {12, SHIFT, 36}, }, {{-1, REDUCE, 33}, {13, SHIFT, 26}, {14,
   * SHIFT, 27}, }, {{-1, REDUCE, 34}, {13, SHIFT, 26}, {14, SHIFT, 27}, },
   * {{-1, REDUCE, 35}, {13, SHIFT, 26}, {14, SHIFT, 27}, }, {{-1, REDUCE, 36},
   * {13, SHIFT, 26}, {14, SHIFT, 27}, }, {{-1, REDUCE, 37}, {13, SHIFT, 26},
   * {14, SHIFT, 27}, }, {{-1, REDUCE, 38}, {13, SHIFT, 26}, {14, SHIFT, 27}, },
   * {{-1, REDUCE, 6}, }, {{-1, REDUCE, 7}, }, {{-1, REDUCE, 8}, }, {{-1, ERROR,
   * 57}, {13, SHIFT, 26}, {14, SHIFT, 27}, {15, SHIFT, 28}, {16, SHIFT, 29},
   * {17, SHIFT, 30}, {18, SHIFT, 31}, {19, SHIFT, 32}, {20, SHIFT, 33}, },
   * {{-1, REDUCE, 26}, {21, SHIFT, 38}, }, {{-1, REDUCE, 28}, }, {{-1, REDUCE,
   * 18}, }, {{-1, REDUCE, 20}, {4, SHIFT, 66}, }, {{-1, ERROR, 62}, {2, SHIFT,
   * 67}, }, {{-1, REDUCE, 23}, }, {{-1, ERROR, 64}, {3, SHIFT, 68}, }, {{-1,
   * REDUCE, 16}, }, {{-1, REDUCE, 24}, }, {{-1, REDUCE, 19}, }, {{-1, REDUCE,
   * 21}, {4, SHIFT, 66}, }, {{-1, REDUCE, 22}, }, };
   */
  private static int[][][] gotoTable;
  /*
   * { {{-1, 8}, }, {{-1, 57}, {0, 9}, {5, 21}, {23, 42}, {28, 48}, {29, 49},
   * {30, 50}, {31, 51}, {32, 52}, {33, 53}, }, {{-1, 10}, {26, 46}, {27, 47}, },
   * {{-1, 11}, {34, 54}, {35, 55}, {36, 56}, }, {{-1, 12}, {6, 24}, }, {{-1,
   * 13}, }, {{-1, 14}, }, {{-1, 45}, }, {{-1, 62}, }, {{-1, 63}, {64, 69}, },
   * {{-1, 15}, {5, 22}, }, {{-1, 16}, {37, 58}, }, {{-1, 17}, {38, 59}, },
   * {{-1, 18}, }, {{-1, 19}, }, {{-1, 64}, }, };
   */
  private static String[] errorMessages;
  /*
   * { "expecting: '${', integer literal, double literal, boolean literal, '(',
   * '-', func id", "expecting: identifier", "expecting: ')', '*', '/', '%',
   * '+', '-', '==', '!=', ' <', ' <=', '>', '>=', '&&', '||', EOF", "expecting:
   * ')', '&&', '||', EOF", "expecting: '${', integer literal, double literal,
   * '(', func id", "expecting: '('", "expecting: EOF", "expecting: '+', '-',
   * '==', '!=', ' <', ' <=', '>', '>=', EOF", "expecting: '||', EOF",
   * "expecting: '}'", "expecting: ')', '+', '-', '==', '!=', ' <', ' <=', '>',
   * '>='", "expecting: ')', '||'", "expecting: '${', integer literal, double
   * literal, '(', '-', func id", "expecting: '$', '${'", "expecting: ')', '+',
   * '-'", "expecting: func id", "expecting: ')'", "expecting: ')', '+', '-',
   * '&&', '||', EOF", "expecting: '+', '-', '==', '!=', ' <', ' <=', '>',
   * '>='", "expecting: '}', ','", };
   */
  private static int[] errors;
  /*
   * { 0, 1, 2, 2, 3, 0, 4, 5, 6, 7, 2, 2, 2, 2, 2, 8, 3, 3, 3, 3, 9, 10, 11,
   * 12, 2, 13, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 0, 0, 2, 2, 3, 14,
   * 15, 1, 16, 2, 2, 17, 17, 17, 17, 17, 17, 2, 2, 2, 18, 3, 3, 16, 19, 9, 1,
   * 1, 2, 1, 16, 19, 1, };
   */
}
