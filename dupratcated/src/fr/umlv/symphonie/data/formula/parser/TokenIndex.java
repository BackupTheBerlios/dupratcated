/* This file was generated by SableCC (http://www.sablecc.org/). */

package fr.umlv.symphonie.data.formula.parser;

import fr.umlv.symphonie.data.formula.analysis.AnalysisAdapter;
import fr.umlv.symphonie.data.formula.node.EOF;
import fr.umlv.symphonie.data.formula.node.TAdditionOperator;
import fr.umlv.symphonie.data.formula.node.TBlockEnd;
import fr.umlv.symphonie.data.formula.node.TBlockPrefix;
import fr.umlv.symphonie.data.formula.node.TBlockStart;
import fr.umlv.symphonie.data.formula.node.TBooleanLiteral;
import fr.umlv.symphonie.data.formula.node.TDivisionOperator;
import fr.umlv.symphonie.data.formula.node.TDoubleLiteral;
import fr.umlv.symphonie.data.formula.node.TEquals;
import fr.umlv.symphonie.data.formula.node.TFuncId;
import fr.umlv.symphonie.data.formula.node.TGreaterThan;
import fr.umlv.symphonie.data.formula.node.TGreaterThanOrEquals;
import fr.umlv.symphonie.data.formula.node.TIdSeparator;
import fr.umlv.symphonie.data.formula.node.TIdentifier;
import fr.umlv.symphonie.data.formula.node.TIntegerLiteral;
import fr.umlv.symphonie.data.formula.node.TLeftParenthesis;
import fr.umlv.symphonie.data.formula.node.TLessThan;
import fr.umlv.symphonie.data.formula.node.TLessThanOrEquals;
import fr.umlv.symphonie.data.formula.node.TLogicalAndOperator;
import fr.umlv.symphonie.data.formula.node.TLogicalOrOperator;
import fr.umlv.symphonie.data.formula.node.TModulusOperator;
import fr.umlv.symphonie.data.formula.node.TMultiplicationOperator;
import fr.umlv.symphonie.data.formula.node.TNotEquals;
import fr.umlv.symphonie.data.formula.node.TRightParenthesis;
import fr.umlv.symphonie.data.formula.node.TSubstractionOperator;

class TokenIndex extends AnalysisAdapter {

  int index;

  public void caseTBlockPrefix(TBlockPrefix node) {
    index = 0;
  }

  public void caseTBlockStart(TBlockStart node) {
    index = 1;
  }

  public void caseTBlockEnd(TBlockEnd node) {
    index = 2;
  }

  public void caseTIdentifier(TIdentifier node) {
    index = 3;
  }

  public void caseTIdSeparator(TIdSeparator node) {
    index = 4;
  }

  public void caseTIntegerLiteral(TIntegerLiteral node) {
    index = 5;
  }

  public void caseTDoubleLiteral(TDoubleLiteral node) {
    index = 6;
  }

  public void caseTBooleanLiteral(TBooleanLiteral node) {
    index = 7;
  }

  public void caseTLeftParenthesis(TLeftParenthesis node) {
    index = 8;
  }

  public void caseTRightParenthesis(TRightParenthesis node) {
    index = 9;
  }

  public void caseTMultiplicationOperator(TMultiplicationOperator node) {
    index = 10;
  }

  public void caseTDivisionOperator(TDivisionOperator node) {
    index = 11;
  }

  public void caseTModulusOperator(TModulusOperator node) {
    index = 12;
  }

  public void caseTAdditionOperator(TAdditionOperator node) {
    index = 13;
  }

  public void caseTSubstractionOperator(TSubstractionOperator node) {
    index = 14;
  }

  public void caseTEquals(TEquals node) {
    index = 15;
  }

  public void caseTNotEquals(TNotEquals node) {
    index = 16;
  }

  public void caseTLessThan(TLessThan node) {
    index = 17;
  }

  public void caseTLessThanOrEquals(TLessThanOrEquals node) {
    index = 18;
  }

  public void caseTGreaterThan(TGreaterThan node) {
    index = 19;
  }

  public void caseTGreaterThanOrEquals(TGreaterThanOrEquals node) {
    index = 20;
  }

  public void caseTLogicalAndOperator(TLogicalAndOperator node) {
    index = 21;
  }

  public void caseTLogicalOrOperator(TLogicalOrOperator node) {
    index = 22;
  }

  public void caseTFuncId(TFuncId node) {
    index = 23;
  }

  public void caseEOF(EOF node) {
    index = 24;
  }
}
