/* This file was generated by SableCC (http://www.sablecc.org/). */

package fr.umlv.symphonie.data.formula.analysis;

import fr.umlv.symphonie.data.formula.node.AAdditionAdditiveExpression;
import fr.umlv.symphonie.data.formula.node.ABooleanExpression;
import fr.umlv.symphonie.data.formula.node.ACellBlockExpression;
import fr.umlv.symphonie.data.formula.node.ACellEvaluatedExpression;
import fr.umlv.symphonie.data.formula.node.AComparativeLogicalAndExpression;
import fr.umlv.symphonie.data.formula.node.ADataBlockExpression;
import fr.umlv.symphonie.data.formula.node.ADivisionMultiplicativeExpression;
import fr.umlv.symphonie.data.formula.node.ADoubleLiteralExpression;
import fr.umlv.symphonie.data.formula.node.AEqualityComparativeExpression;
import fr.umlv.symphonie.data.formula.node.AEqualsEqualityExpression;
import fr.umlv.symphonie.data.formula.node.AEvaluatedNumericExpression;
import fr.umlv.symphonie.data.formula.node.AFunctionEvaluatedExpression;
import fr.umlv.symphonie.data.formula.node.AGreaterThanOrEqualsRelationalExpression;
import fr.umlv.symphonie.data.formula.node.AGreaterThanRelationalExpression;
import fr.umlv.symphonie.data.formula.node.AIdentifiers;
import fr.umlv.symphonie.data.formula.node.AIntegerLiteralExpression;
import fr.umlv.symphonie.data.formula.node.ALessThanOrEqualsRelationalExpression;
import fr.umlv.symphonie.data.formula.node.ALessThanRelationalExpression;
import fr.umlv.symphonie.data.formula.node.ALiteralComparativeExpression;
import fr.umlv.symphonie.data.formula.node.ALiteralNumericExpression;
import fr.umlv.symphonie.data.formula.node.ALogicalAndLogicalAndExpression;
import fr.umlv.symphonie.data.formula.node.ALogicalAndLogicalOrExpression;
import fr.umlv.symphonie.data.formula.node.ALogicalOrLogicalOrExpression;
import fr.umlv.symphonie.data.formula.node.AMinusUnaryExpression;
import fr.umlv.symphonie.data.formula.node.AModulusMultiplicativeExpression;
import fr.umlv.symphonie.data.formula.node.AMultiplicationMultiplicativeExpression;
import fr.umlv.symphonie.data.formula.node.AMultiplicativeAdditiveExpression;
import fr.umlv.symphonie.data.formula.node.ANotEqualsEqualityExpression;
import fr.umlv.symphonie.data.formula.node.ANumericExpression;
import fr.umlv.symphonie.data.formula.node.ANumericUnaryExpression;
import fr.umlv.symphonie.data.formula.node.AParenthethicComparativeExpression;
import fr.umlv.symphonie.data.formula.node.AParentheticNumericExpression;
import fr.umlv.symphonie.data.formula.node.ARelationalComparativeExpression;
import fr.umlv.symphonie.data.formula.node.ASeparatorSuffixedId;
import fr.umlv.symphonie.data.formula.node.ASubstractionAdditiveExpression;
import fr.umlv.symphonie.data.formula.node.AUnaryMultiplicativeExpression;
import fr.umlv.symphonie.data.formula.node.Node;
import fr.umlv.symphonie.data.formula.node.PSeparatorSuffixedId;
import fr.umlv.symphonie.data.formula.node.Start;

public class DepthFirstAdapter extends AnalysisAdapter {

  public void inStart(Start node) {
    defaultIn(node);
  }

  public void outStart(Start node) {
    defaultOut(node);
  }

  public void defaultIn(Node node) {
  }

  public void defaultOut(Node node) {
  }

  public void caseStart(Start node) {
    inStart(node);
    node.getPExpression().apply(this);
    node.getEOF().apply(this);
    outStart(node);
  }

  public void inANumericExpression(ANumericExpression node) {
    defaultIn(node);
  }

  public void outANumericExpression(ANumericExpression node) {
    defaultOut(node);
  }

  public void caseANumericExpression(ANumericExpression node) {
    inANumericExpression(node);
    if (node.getAdditiveExpression() != null) {
      node.getAdditiveExpression().apply(this);
    }
    outANumericExpression(node);
  }

  public void inABooleanExpression(ABooleanExpression node) {
    defaultIn(node);
  }

  public void outABooleanExpression(ABooleanExpression node) {
    defaultOut(node);
  }

  public void caseABooleanExpression(ABooleanExpression node) {
    inABooleanExpression(node);
    if (node.getLogicalOrExpression() != null) {
      node.getLogicalOrExpression().apply(this);
    }
    outABooleanExpression(node);
  }

  public void inAMultiplicativeAdditiveExpression(
      AMultiplicativeAdditiveExpression node) {
    defaultIn(node);
  }

  public void outAMultiplicativeAdditiveExpression(
      AMultiplicativeAdditiveExpression node) {
    defaultOut(node);
  }

  public void caseAMultiplicativeAdditiveExpression(
      AMultiplicativeAdditiveExpression node) {
    inAMultiplicativeAdditiveExpression(node);
    if (node.getMultiplicativeExpression() != null) {
      node.getMultiplicativeExpression().apply(this);
    }
    outAMultiplicativeAdditiveExpression(node);
  }

  public void inAAdditionAdditiveExpression(AAdditionAdditiveExpression node) {
    defaultIn(node);
  }

  public void outAAdditionAdditiveExpression(AAdditionAdditiveExpression node) {
    defaultOut(node);
  }

  public void caseAAdditionAdditiveExpression(AAdditionAdditiveExpression node) {
    inAAdditionAdditiveExpression(node);
    if (node.getLeft() != null) {
      node.getLeft().apply(this);
    }
    if (node.getAdditionOperator() != null) {
      node.getAdditionOperator().apply(this);
    }
    if (node.getRight() != null) {
      node.getRight().apply(this);
    }
    outAAdditionAdditiveExpression(node);
  }

  public void inASubstractionAdditiveExpression(
      ASubstractionAdditiveExpression node) {
    defaultIn(node);
  }

  public void outASubstractionAdditiveExpression(
      ASubstractionAdditiveExpression node) {
    defaultOut(node);
  }

  public void caseASubstractionAdditiveExpression(
      ASubstractionAdditiveExpression node) {
    inASubstractionAdditiveExpression(node);
    if (node.getLeft() != null) {
      node.getLeft().apply(this);
    }
    if (node.getSubstractionOperator() != null) {
      node.getSubstractionOperator().apply(this);
    }
    if (node.getRight() != null) {
      node.getRight().apply(this);
    }
    outASubstractionAdditiveExpression(node);
  }

  public void inAUnaryMultiplicativeExpression(
      AUnaryMultiplicativeExpression node) {
    defaultIn(node);
  }

  public void outAUnaryMultiplicativeExpression(
      AUnaryMultiplicativeExpression node) {
    defaultOut(node);
  }

  public void caseAUnaryMultiplicativeExpression(
      AUnaryMultiplicativeExpression node) {
    inAUnaryMultiplicativeExpression(node);
    if (node.getUnaryExpression() != null) {
      node.getUnaryExpression().apply(this);
    }
    outAUnaryMultiplicativeExpression(node);
  }

  public void inAMultiplicationMultiplicativeExpression(
      AMultiplicationMultiplicativeExpression node) {
    defaultIn(node);
  }

  public void outAMultiplicationMultiplicativeExpression(
      AMultiplicationMultiplicativeExpression node) {
    defaultOut(node);
  }

  public void caseAMultiplicationMultiplicativeExpression(
      AMultiplicationMultiplicativeExpression node) {
    inAMultiplicationMultiplicativeExpression(node);
    if (node.getLeft() != null) {
      node.getLeft().apply(this);
    }
    if (node.getMultiplicationOperator() != null) {
      node.getMultiplicationOperator().apply(this);
    }
    if (node.getRight() != null) {
      node.getRight().apply(this);
    }
    outAMultiplicationMultiplicativeExpression(node);
  }

  public void inADivisionMultiplicativeExpression(
      ADivisionMultiplicativeExpression node) {
    defaultIn(node);
  }

  public void outADivisionMultiplicativeExpression(
      ADivisionMultiplicativeExpression node) {
    defaultOut(node);
  }

  public void caseADivisionMultiplicativeExpression(
      ADivisionMultiplicativeExpression node) {
    inADivisionMultiplicativeExpression(node);
    if (node.getLeft() != null) {
      node.getLeft().apply(this);
    }
    if (node.getDivisionOperator() != null) {
      node.getDivisionOperator().apply(this);
    }
    if (node.getRight() != null) {
      node.getRight().apply(this);
    }
    outADivisionMultiplicativeExpression(node);
  }

  public void inAModulusMultiplicativeExpression(
      AModulusMultiplicativeExpression node) {
    defaultIn(node);
  }

  public void outAModulusMultiplicativeExpression(
      AModulusMultiplicativeExpression node) {
    defaultOut(node);
  }

  public void caseAModulusMultiplicativeExpression(
      AModulusMultiplicativeExpression node) {
    inAModulusMultiplicativeExpression(node);
    if (node.getLeft() != null) {
      node.getLeft().apply(this);
    }
    if (node.getModulusOperator() != null) {
      node.getModulusOperator().apply(this);
    }
    if (node.getRight() != null) {
      node.getRight().apply(this);
    }
    outAModulusMultiplicativeExpression(node);
  }

  public void inANumericUnaryExpression(ANumericUnaryExpression node) {
    defaultIn(node);
  }

  public void outANumericUnaryExpression(ANumericUnaryExpression node) {
    defaultOut(node);
  }

  public void caseANumericUnaryExpression(ANumericUnaryExpression node) {
    inANumericUnaryExpression(node);
    if (node.getNumericExpression() != null) {
      node.getNumericExpression().apply(this);
    }
    outANumericUnaryExpression(node);
  }

  public void inAMinusUnaryExpression(AMinusUnaryExpression node) {
    defaultIn(node);
  }

  public void outAMinusUnaryExpression(AMinusUnaryExpression node) {
    defaultOut(node);
  }

  public void caseAMinusUnaryExpression(AMinusUnaryExpression node) {
    inAMinusUnaryExpression(node);
    if (node.getSubstractionOperator() != null) {
      node.getSubstractionOperator().apply(this);
    }
    if (node.getNumericExpression() != null) {
      node.getNumericExpression().apply(this);
    }
    outAMinusUnaryExpression(node);
  }

  public void inALiteralNumericExpression(ALiteralNumericExpression node) {
    defaultIn(node);
  }

  public void outALiteralNumericExpression(ALiteralNumericExpression node) {
    defaultOut(node);
  }

  public void caseALiteralNumericExpression(ALiteralNumericExpression node) {
    inALiteralNumericExpression(node);
    if (node.getLiteralExpression() != null) {
      node.getLiteralExpression().apply(this);
    }
    outALiteralNumericExpression(node);
  }

  public void inAEvaluatedNumericExpression(AEvaluatedNumericExpression node) {
    defaultIn(node);
  }

  public void outAEvaluatedNumericExpression(AEvaluatedNumericExpression node) {
    defaultOut(node);
  }

  public void caseAEvaluatedNumericExpression(AEvaluatedNumericExpression node) {
    inAEvaluatedNumericExpression(node);
    if (node.getEvaluatedExpression() != null) {
      node.getEvaluatedExpression().apply(this);
    }
    outAEvaluatedNumericExpression(node);
  }

  public void inAParentheticNumericExpression(AParentheticNumericExpression node) {
    defaultIn(node);
  }

  public void outAParentheticNumericExpression(
      AParentheticNumericExpression node) {
    defaultOut(node);
  }

  public void caseAParentheticNumericExpression(
      AParentheticNumericExpression node) {
    inAParentheticNumericExpression(node);
    if (node.getLeftParenthesis() != null) {
      node.getLeftParenthesis().apply(this);
    }
    if (node.getAdditiveExpression() != null) {
      node.getAdditiveExpression().apply(this);
    }
    if (node.getRightParenthesis() != null) {
      node.getRightParenthesis().apply(this);
    }
    outAParentheticNumericExpression(node);
  }

  public void inAIntegerLiteralExpression(AIntegerLiteralExpression node) {
    defaultIn(node);
  }

  public void outAIntegerLiteralExpression(AIntegerLiteralExpression node) {
    defaultOut(node);
  }

  public void caseAIntegerLiteralExpression(AIntegerLiteralExpression node) {
    inAIntegerLiteralExpression(node);
    if (node.getIntegerLiteral() != null) {
      node.getIntegerLiteral().apply(this);
    }
    outAIntegerLiteralExpression(node);
  }

  public void inADoubleLiteralExpression(ADoubleLiteralExpression node) {
    defaultIn(node);
  }

  public void outADoubleLiteralExpression(ADoubleLiteralExpression node) {
    defaultOut(node);
  }

  public void caseADoubleLiteralExpression(ADoubleLiteralExpression node) {
    inADoubleLiteralExpression(node);
    if (node.getDoubleLiteral() != null) {
      node.getDoubleLiteral().apply(this);
    }
    outADoubleLiteralExpression(node);
  }

  public void inAFunctionEvaluatedExpression(AFunctionEvaluatedExpression node) {
    defaultIn(node);
  }

  public void outAFunctionEvaluatedExpression(AFunctionEvaluatedExpression node) {
    defaultOut(node);
  }

  public void caseAFunctionEvaluatedExpression(AFunctionEvaluatedExpression node) {
    inAFunctionEvaluatedExpression(node);
    if (node.getFuncId() != null) {
      node.getFuncId().apply(this);
    }
    if (node.getLeftParenthesis() != null) {
      node.getLeftParenthesis().apply(this);
    }
    if (node.getBlockExpression() != null) {
      node.getBlockExpression().apply(this);
    }
    if (node.getRightParenthesis() != null) {
      node.getRightParenthesis().apply(this);
    }
    outAFunctionEvaluatedExpression(node);
  }

  public void inACellEvaluatedExpression(ACellEvaluatedExpression node) {
    defaultIn(node);
  }

  public void outACellEvaluatedExpression(ACellEvaluatedExpression node) {
    defaultOut(node);
  }

  public void caseACellEvaluatedExpression(ACellEvaluatedExpression node) {
    inACellEvaluatedExpression(node);
    if (node.getBlockStart() != null) {
      node.getBlockStart().apply(this);
    }
    if (node.getIdentifier() != null) {
      node.getIdentifier().apply(this);
    }
    if (node.getBlockEnd() != null) {
      node.getBlockEnd().apply(this);
    }
    outACellEvaluatedExpression(node);
  }

  public void inADataBlockExpression(ADataBlockExpression node) {
    defaultIn(node);
  }

  public void outADataBlockExpression(ADataBlockExpression node) {
    defaultOut(node);
  }

  public void caseADataBlockExpression(ADataBlockExpression node) {
    inADataBlockExpression(node);
    if (node.getBlockPrefix() != null) {
      node.getBlockPrefix().apply(this);
    }
    if (node.getFuncId() != null) {
      node.getFuncId().apply(this);
    }
    outADataBlockExpression(node);
  }

  public void inACellBlockExpression(ACellBlockExpression node) {
    defaultIn(node);
  }

  public void outACellBlockExpression(ACellBlockExpression node) {
    defaultOut(node);
  }

  public void caseACellBlockExpression(ACellBlockExpression node) {
    inACellBlockExpression(node);
    if (node.getBlockStart() != null) {
      node.getBlockStart().apply(this);
    }
    if (node.getIdentifiers() != null) {
      node.getIdentifiers().apply(this);
    }
    if (node.getBlockEnd() != null) {
      node.getBlockEnd().apply(this);
    }
    outACellBlockExpression(node);
  }

  public void inAIdentifiers(AIdentifiers node) {
    defaultIn(node);
  }

  public void outAIdentifiers(AIdentifiers node) {
    defaultOut(node);
  }

  public void caseAIdentifiers(AIdentifiers node) {
    inAIdentifiers(node);
    {
      Object temp[] = node.getSeparatorSuffixedId().toArray();
      for (int i = 0; i < temp.length; i++) {
        ((PSeparatorSuffixedId) temp[i]).apply(this);
      }
    }
    if (node.getIdentifier() != null) {
      node.getIdentifier().apply(this);
    }
    outAIdentifiers(node);
  }

  public void inASeparatorSuffixedId(ASeparatorSuffixedId node) {
    defaultIn(node);
  }

  public void outASeparatorSuffixedId(ASeparatorSuffixedId node) {
    defaultOut(node);
  }

  public void caseASeparatorSuffixedId(ASeparatorSuffixedId node) {
    inASeparatorSuffixedId(node);
    if (node.getIdentifier() != null) {
      node.getIdentifier().apply(this);
    }
    if (node.getIdSeparator() != null) {
      node.getIdSeparator().apply(this);
    }
    outASeparatorSuffixedId(node);
  }

  public void inALogicalAndLogicalOrExpression(
      ALogicalAndLogicalOrExpression node) {
    defaultIn(node);
  }

  public void outALogicalAndLogicalOrExpression(
      ALogicalAndLogicalOrExpression node) {
    defaultOut(node);
  }

  public void caseALogicalAndLogicalOrExpression(
      ALogicalAndLogicalOrExpression node) {
    inALogicalAndLogicalOrExpression(node);
    if (node.getLogicalAndExpression() != null) {
      node.getLogicalAndExpression().apply(this);
    }
    outALogicalAndLogicalOrExpression(node);
  }

  public void inALogicalOrLogicalOrExpression(ALogicalOrLogicalOrExpression node) {
    defaultIn(node);
  }

  public void outALogicalOrLogicalOrExpression(
      ALogicalOrLogicalOrExpression node) {
    defaultOut(node);
  }

  public void caseALogicalOrLogicalOrExpression(
      ALogicalOrLogicalOrExpression node) {
    inALogicalOrLogicalOrExpression(node);
    if (node.getLeft() != null) {
      node.getLeft().apply(this);
    }
    if (node.getLogicalOrOperator() != null) {
      node.getLogicalOrOperator().apply(this);
    }
    if (node.getRight() != null) {
      node.getRight().apply(this);
    }
    outALogicalOrLogicalOrExpression(node);
  }

  public void inAComparativeLogicalAndExpression(
      AComparativeLogicalAndExpression node) {
    defaultIn(node);
  }

  public void outAComparativeLogicalAndExpression(
      AComparativeLogicalAndExpression node) {
    defaultOut(node);
  }

  public void caseAComparativeLogicalAndExpression(
      AComparativeLogicalAndExpression node) {
    inAComparativeLogicalAndExpression(node);
    if (node.getComparativeExpression() != null) {
      node.getComparativeExpression().apply(this);
    }
    outAComparativeLogicalAndExpression(node);
  }

  public void inALogicalAndLogicalAndExpression(
      ALogicalAndLogicalAndExpression node) {
    defaultIn(node);
  }

  public void outALogicalAndLogicalAndExpression(
      ALogicalAndLogicalAndExpression node) {
    defaultOut(node);
  }

  public void caseALogicalAndLogicalAndExpression(
      ALogicalAndLogicalAndExpression node) {
    inALogicalAndLogicalAndExpression(node);
    if (node.getLeft() != null) {
      node.getLeft().apply(this);
    }
    if (node.getLogicalAndOperator() != null) {
      node.getLogicalAndOperator().apply(this);
    }
    if (node.getRight() != null) {
      node.getRight().apply(this);
    }
    outALogicalAndLogicalAndExpression(node);
  }

  public void inAEqualityComparativeExpression(
      AEqualityComparativeExpression node) {
    defaultIn(node);
  }

  public void outAEqualityComparativeExpression(
      AEqualityComparativeExpression node) {
    defaultOut(node);
  }

  public void caseAEqualityComparativeExpression(
      AEqualityComparativeExpression node) {
    inAEqualityComparativeExpression(node);
    if (node.getEqualityExpression() != null) {
      node.getEqualityExpression().apply(this);
    }
    outAEqualityComparativeExpression(node);
  }

  public void inARelationalComparativeExpression(
      ARelationalComparativeExpression node) {
    defaultIn(node);
  }

  public void outARelationalComparativeExpression(
      ARelationalComparativeExpression node) {
    defaultOut(node);
  }

  public void caseARelationalComparativeExpression(
      ARelationalComparativeExpression node) {
    inARelationalComparativeExpression(node);
    if (node.getRelationalExpression() != null) {
      node.getRelationalExpression().apply(this);
    }
    outARelationalComparativeExpression(node);
  }

  public void inALiteralComparativeExpression(ALiteralComparativeExpression node) {
    defaultIn(node);
  }

  public void outALiteralComparativeExpression(
      ALiteralComparativeExpression node) {
    defaultOut(node);
  }

  public void caseALiteralComparativeExpression(
      ALiteralComparativeExpression node) {
    inALiteralComparativeExpression(node);
    if (node.getBooleanLiteral() != null) {
      node.getBooleanLiteral().apply(this);
    }
    outALiteralComparativeExpression(node);
  }

  public void inAParenthethicComparativeExpression(
      AParenthethicComparativeExpression node) {
    defaultIn(node);
  }

  public void outAParenthethicComparativeExpression(
      AParenthethicComparativeExpression node) {
    defaultOut(node);
  }

  public void caseAParenthethicComparativeExpression(
      AParenthethicComparativeExpression node) {
    inAParenthethicComparativeExpression(node);
    if (node.getLeftParenthesis() != null) {
      node.getLeftParenthesis().apply(this);
    }
    if (node.getLogicalOrExpression() != null) {
      node.getLogicalOrExpression().apply(this);
    }
    if (node.getRightParenthesis() != null) {
      node.getRightParenthesis().apply(this);
    }
    outAParenthethicComparativeExpression(node);
  }

  public void inAEqualsEqualityExpression(AEqualsEqualityExpression node) {
    defaultIn(node);
  }

  public void outAEqualsEqualityExpression(AEqualsEqualityExpression node) {
    defaultOut(node);
  }

  public void caseAEqualsEqualityExpression(AEqualsEqualityExpression node) {
    inAEqualsEqualityExpression(node);
    if (node.getLeft() != null) {
      node.getLeft().apply(this);
    }
    if (node.getEquals() != null) {
      node.getEquals().apply(this);
    }
    if (node.getRight() != null) {
      node.getRight().apply(this);
    }
    outAEqualsEqualityExpression(node);
  }

  public void inANotEqualsEqualityExpression(ANotEqualsEqualityExpression node) {
    defaultIn(node);
  }

  public void outANotEqualsEqualityExpression(ANotEqualsEqualityExpression node) {
    defaultOut(node);
  }

  public void caseANotEqualsEqualityExpression(ANotEqualsEqualityExpression node) {
    inANotEqualsEqualityExpression(node);
    if (node.getLeft() != null) {
      node.getLeft().apply(this);
    }
    if (node.getNotEquals() != null) {
      node.getNotEquals().apply(this);
    }
    if (node.getRight() != null) {
      node.getRight().apply(this);
    }
    outANotEqualsEqualityExpression(node);
  }

  public void inALessThanRelationalExpression(ALessThanRelationalExpression node) {
    defaultIn(node);
  }

  public void outALessThanRelationalExpression(
      ALessThanRelationalExpression node) {
    defaultOut(node);
  }

  public void caseALessThanRelationalExpression(
      ALessThanRelationalExpression node) {
    inALessThanRelationalExpression(node);
    if (node.getLeft() != null) {
      node.getLeft().apply(this);
    }
    if (node.getLessThan() != null) {
      node.getLessThan().apply(this);
    }
    if (node.getRight() != null) {
      node.getRight().apply(this);
    }
    outALessThanRelationalExpression(node);
  }

  public void inALessThanOrEqualsRelationalExpression(
      ALessThanOrEqualsRelationalExpression node) {
    defaultIn(node);
  }

  public void outALessThanOrEqualsRelationalExpression(
      ALessThanOrEqualsRelationalExpression node) {
    defaultOut(node);
  }

  public void caseALessThanOrEqualsRelationalExpression(
      ALessThanOrEqualsRelationalExpression node) {
    inALessThanOrEqualsRelationalExpression(node);
    if (node.getLeft() != null) {
      node.getLeft().apply(this);
    }
    if (node.getLessThanOrEquals() != null) {
      node.getLessThanOrEquals().apply(this);
    }
    if (node.getRight() != null) {
      node.getRight().apply(this);
    }
    outALessThanOrEqualsRelationalExpression(node);
  }

  public void inAGreaterThanRelationalExpression(
      AGreaterThanRelationalExpression node) {
    defaultIn(node);
  }

  public void outAGreaterThanRelationalExpression(
      AGreaterThanRelationalExpression node) {
    defaultOut(node);
  }

  public void caseAGreaterThanRelationalExpression(
      AGreaterThanRelationalExpression node) {
    inAGreaterThanRelationalExpression(node);
    if (node.getLeft() != null) {
      node.getLeft().apply(this);
    }
    if (node.getGreaterThan() != null) {
      node.getGreaterThan().apply(this);
    }
    if (node.getRight() != null) {
      node.getRight().apply(this);
    }
    outAGreaterThanRelationalExpression(node);
  }

  public void inAGreaterThanOrEqualsRelationalExpression(
      AGreaterThanOrEqualsRelationalExpression node) {
    defaultIn(node);
  }

  public void outAGreaterThanOrEqualsRelationalExpression(
      AGreaterThanOrEqualsRelationalExpression node) {
    defaultOut(node);
  }

  public void caseAGreaterThanOrEqualsRelationalExpression(
      AGreaterThanOrEqualsRelationalExpression node) {
    inAGreaterThanOrEqualsRelationalExpression(node);
    if (node.getLeft() != null) {
      node.getLeft().apply(this);
    }
    if (node.getGreaterThanOrEquals() != null) {
      node.getGreaterThanOrEquals().apply(this);
    }
    if (node.getRight() != null) {
      node.getRight().apply(this);
    }
    outAGreaterThanOrEqualsRelationalExpression(node);
  }
}
