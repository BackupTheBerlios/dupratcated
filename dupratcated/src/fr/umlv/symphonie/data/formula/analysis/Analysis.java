/* This file was generated by SableCC (http://www.sablecc.org/). */

package fr.umlv.symphonie.data.formula.analysis;

import fr.umlv.symphonie.data.formula.node.AAdditionAdditiveExpression;
import fr.umlv.symphonie.data.formula.node.ABooleanExpression;
import fr.umlv.symphonie.data.formula.node.ACellBlockExpression;
import fr.umlv.symphonie.data.formula.node.ACellEvaluatedExpression;
import fr.umlv.symphonie.data.formula.node.AComparativeLogicalAndExpression;
import fr.umlv.symphonie.data.formula.node.ADataBlockExpression;
import fr.umlv.symphonie.data.formula.node.ADivisionMultiplicativeExpression;
import fr.umlv.symphonie.data.formula.node.ADoubleLiteralExpression;
import fr.umlv.symphonie.data.formula.node.AEqualityComparativeExpression;
import fr.umlv.symphonie.data.formula.node.AEqualsEqualityExpression;
import fr.umlv.symphonie.data.formula.node.AEvaluatedNumericExpression;
import fr.umlv.symphonie.data.formula.node.AFunctionEvaluatedExpression;
import fr.umlv.symphonie.data.formula.node.AGreaterThanOrEqualsRelationalExpression;
import fr.umlv.symphonie.data.formula.node.AGreaterThanRelationalExpression;
import fr.umlv.symphonie.data.formula.node.AIdentifiers;
import fr.umlv.symphonie.data.formula.node.AIntegerLiteralExpression;
import fr.umlv.symphonie.data.formula.node.ALessThanOrEqualsRelationalExpression;
import fr.umlv.symphonie.data.formula.node.ALessThanRelationalExpression;
import fr.umlv.symphonie.data.formula.node.ALiteralComparativeExpression;
import fr.umlv.symphonie.data.formula.node.ALiteralNumericExpression;
import fr.umlv.symphonie.data.formula.node.ALogicalAndLogicalAndExpression;
import fr.umlv.symphonie.data.formula.node.ALogicalAndLogicalOrExpression;
import fr.umlv.symphonie.data.formula.node.ALogicalOrLogicalOrExpression;
import fr.umlv.symphonie.data.formula.node.AMinusUnaryExpression;
import fr.umlv.symphonie.data.formula.node.AModulusMultiplicativeExpression;
import fr.umlv.symphonie.data.formula.node.AMultiplicationMultiplicativeExpression;
import fr.umlv.symphonie.data.formula.node.AMultiplicativeAdditiveExpression;
import fr.umlv.symphonie.data.formula.node.ANotEqualsEqualityExpression;
import fr.umlv.symphonie.data.formula.node.ANumericExpression;
import fr.umlv.symphonie.data.formula.node.ANumericUnaryExpression;
import fr.umlv.symphonie.data.formula.node.AParenthethicComparativeExpression;
import fr.umlv.symphonie.data.formula.node.AParentheticNumericExpression;
import fr.umlv.symphonie.data.formula.node.ARelationalComparativeExpression;
import fr.umlv.symphonie.data.formula.node.ASeparatorSuffixedId;
import fr.umlv.symphonie.data.formula.node.ASubstractionAdditiveExpression;
import fr.umlv.symphonie.data.formula.node.AUnaryMultiplicativeExpression;
import fr.umlv.symphonie.data.formula.node.EOF;
import fr.umlv.symphonie.data.formula.node.Node;
import fr.umlv.symphonie.data.formula.node.Start;
import fr.umlv.symphonie.data.formula.node.Switch;
import fr.umlv.symphonie.data.formula.node.TAdditionOperator;
import fr.umlv.symphonie.data.formula.node.TBlanks;
import fr.umlv.symphonie.data.formula.node.TBlockEnd;
import fr.umlv.symphonie.data.formula.node.TBlockPrefix;
import fr.umlv.symphonie.data.formula.node.TBlockStart;
import fr.umlv.symphonie.data.formula.node.TBooleanLiteral;
import fr.umlv.symphonie.data.formula.node.TDivisionOperator;
import fr.umlv.symphonie.data.formula.node.TDoubleLiteral;
import fr.umlv.symphonie.data.formula.node.TEquals;
import fr.umlv.symphonie.data.formula.node.TFuncId;
import fr.umlv.symphonie.data.formula.node.TGreaterThan;
import fr.umlv.symphonie.data.formula.node.TGreaterThanOrEquals;
import fr.umlv.symphonie.data.formula.node.TIdSeparator;
import fr.umlv.symphonie.data.formula.node.TIdentifier;
import fr.umlv.symphonie.data.formula.node.TIntegerLiteral;
import fr.umlv.symphonie.data.formula.node.TLeftParenthesis;
import fr.umlv.symphonie.data.formula.node.TLessThan;
import fr.umlv.symphonie.data.formula.node.TLessThanOrEquals;
import fr.umlv.symphonie.data.formula.node.TLogicalAndOperator;
import fr.umlv.symphonie.data.formula.node.TLogicalOrOperator;
import fr.umlv.symphonie.data.formula.node.TModulusOperator;
import fr.umlv.symphonie.data.formula.node.TMultiplicationOperator;
import fr.umlv.symphonie.data.formula.node.TNotEquals;
import fr.umlv.symphonie.data.formula.node.TRightParenthesis;
import fr.umlv.symphonie.data.formula.node.TSubstractionOperator;

public interface Analysis extends Switch {

  Object getIn(Node node);

  void setIn(Node node, Object in);

  Object getOut(Node node);

  void setOut(Node node, Object out);

  void caseStart(Start node);

  void caseANumericExpression(ANumericExpression node);

  void caseABooleanExpression(ABooleanExpression node);

  void caseAMultiplicativeAdditiveExpression(
      AMultiplicativeAdditiveExpression node);

  void caseAAdditionAdditiveExpression(AAdditionAdditiveExpression node);

  void caseASubstractionAdditiveExpression(ASubstractionAdditiveExpression node);

  void caseAUnaryMultiplicativeExpression(AUnaryMultiplicativeExpression node);

  void caseAMultiplicationMultiplicativeExpression(
      AMultiplicationMultiplicativeExpression node);

  void caseADivisionMultiplicativeExpression(
      ADivisionMultiplicativeExpression node);

  void caseAModulusMultiplicativeExpression(
      AModulusMultiplicativeExpression node);

  void caseANumericUnaryExpression(ANumericUnaryExpression node);

  void caseAMinusUnaryExpression(AMinusUnaryExpression node);

  void caseALiteralNumericExpression(ALiteralNumericExpression node);

  void caseAEvaluatedNumericExpression(AEvaluatedNumericExpression node);

  void caseAParentheticNumericExpression(AParentheticNumericExpression node);

  void caseAIntegerLiteralExpression(AIntegerLiteralExpression node);

  void caseADoubleLiteralExpression(ADoubleLiteralExpression node);

  void caseAFunctionEvaluatedExpression(AFunctionEvaluatedExpression node);

  void caseACellEvaluatedExpression(ACellEvaluatedExpression node);

  void caseADataBlockExpression(ADataBlockExpression node);

  void caseACellBlockExpression(ACellBlockExpression node);

  void caseAIdentifiers(AIdentifiers node);

  void caseASeparatorSuffixedId(ASeparatorSuffixedId node);

  void caseALogicalAndLogicalOrExpression(ALogicalAndLogicalOrExpression node);

  void caseALogicalOrLogicalOrExpression(ALogicalOrLogicalOrExpression node);

  void caseAComparativeLogicalAndExpression(
      AComparativeLogicalAndExpression node);

  void caseALogicalAndLogicalAndExpression(ALogicalAndLogicalAndExpression node);

  void caseAEqualityComparativeExpression(AEqualityComparativeExpression node);

  void caseARelationalComparativeExpression(
      ARelationalComparativeExpression node);

  void caseALiteralComparativeExpression(ALiteralComparativeExpression node);

  void caseAParenthethicComparativeExpression(
      AParenthethicComparativeExpression node);

  void caseAEqualsEqualityExpression(AEqualsEqualityExpression node);

  void caseANotEqualsEqualityExpression(ANotEqualsEqualityExpression node);

  void caseALessThanRelationalExpression(ALessThanRelationalExpression node);

  void caseALessThanOrEqualsRelationalExpression(
      ALessThanOrEqualsRelationalExpression node);

  void caseAGreaterThanRelationalExpression(
      AGreaterThanRelationalExpression node);

  void caseAGreaterThanOrEqualsRelationalExpression(
      AGreaterThanOrEqualsRelationalExpression node);

  void caseTBlockPrefix(TBlockPrefix node);

  void caseTBlockStart(TBlockStart node);

  void caseTBlockEnd(TBlockEnd node);

  void caseTIdentifier(TIdentifier node);

  void caseTIdSeparator(TIdSeparator node);

  void caseTBlanks(TBlanks node);

  void caseTIntegerLiteral(TIntegerLiteral node);

  void caseTDoubleLiteral(TDoubleLiteral node);

  void caseTBooleanLiteral(TBooleanLiteral node);

  void caseTLeftParenthesis(TLeftParenthesis node);

  void caseTRightParenthesis(TRightParenthesis node);

  void caseTMultiplicationOperator(TMultiplicationOperator node);

  void caseTDivisionOperator(TDivisionOperator node);

  void caseTModulusOperator(TModulusOperator node);

  void caseTAdditionOperator(TAdditionOperator node);

  void caseTSubstractionOperator(TSubstractionOperator node);

  void caseTEquals(TEquals node);

  void caseTNotEquals(TNotEquals node);

  void caseTLessThan(TLessThan node);

  void caseTLessThanOrEquals(TLessThanOrEquals node);

  void caseTGreaterThan(TGreaterThan node);

  void caseTGreaterThanOrEquals(TGreaterThanOrEquals node);

  void caseTLogicalAndOperator(TLogicalAndOperator node);

  void caseTLogicalOrOperator(TLogicalOrOperator node);

  void caseTFuncId(TFuncId node);

  void caseEOF(EOF node);
}
