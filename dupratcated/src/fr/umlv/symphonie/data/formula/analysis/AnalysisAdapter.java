/* This file was generated by SableCC (http://www.sablecc.org/). */

package fr.umlv.symphonie.data.formula.analysis;

import java.util.Hashtable;

import fr.umlv.symphonie.data.formula.node.AAdditionAdditiveExpression;
import fr.umlv.symphonie.data.formula.node.ABooleanExpression;
import fr.umlv.symphonie.data.formula.node.ACellBlockExpression;
import fr.umlv.symphonie.data.formula.node.ACellEvaluatedExpression;
import fr.umlv.symphonie.data.formula.node.AComparativeLogicalAndExpression;
import fr.umlv.symphonie.data.formula.node.ADataBlockExpression;
import fr.umlv.symphonie.data.formula.node.ADivisionMultiplicativeExpression;
import fr.umlv.symphonie.data.formula.node.ADoubleLiteralExpression;
import fr.umlv.symphonie.data.formula.node.AEqualityComparativeExpression;
import fr.umlv.symphonie.data.formula.node.AEqualsEqualityExpression;
import fr.umlv.symphonie.data.formula.node.AEvaluatedNumericExpression;
import fr.umlv.symphonie.data.formula.node.AFunctionEvaluatedExpression;
import fr.umlv.symphonie.data.formula.node.AGreaterThanOrEqualsRelationalExpression;
import fr.umlv.symphonie.data.formula.node.AGreaterThanRelationalExpression;
import fr.umlv.symphonie.data.formula.node.AIdentifiers;
import fr.umlv.symphonie.data.formula.node.AIntegerLiteralExpression;
import fr.umlv.symphonie.data.formula.node.ALessThanOrEqualsRelationalExpression;
import fr.umlv.symphonie.data.formula.node.ALessThanRelationalExpression;
import fr.umlv.symphonie.data.formula.node.ALiteralComparativeExpression;
import fr.umlv.symphonie.data.formula.node.ALiteralNumericExpression;
import fr.umlv.symphonie.data.formula.node.ALogicalAndLogicalAndExpression;
import fr.umlv.symphonie.data.formula.node.ALogicalAndLogicalOrExpression;
import fr.umlv.symphonie.data.formula.node.ALogicalOrLogicalOrExpression;
import fr.umlv.symphonie.data.formula.node.AMinusUnaryExpression;
import fr.umlv.symphonie.data.formula.node.AModulusMultiplicativeExpression;
import fr.umlv.symphonie.data.formula.node.AMultiplicationMultiplicativeExpression;
import fr.umlv.symphonie.data.formula.node.AMultiplicativeAdditiveExpression;
import fr.umlv.symphonie.data.formula.node.ANotEqualsEqualityExpression;
import fr.umlv.symphonie.data.formula.node.ANumericExpression;
import fr.umlv.symphonie.data.formula.node.ANumericUnaryExpression;
import fr.umlv.symphonie.data.formula.node.AParenthethicComparativeExpression;
import fr.umlv.symphonie.data.formula.node.AParentheticNumericExpression;
import fr.umlv.symphonie.data.formula.node.ARelationalComparativeExpression;
import fr.umlv.symphonie.data.formula.node.ASeparatorSuffixedId;
import fr.umlv.symphonie.data.formula.node.ASubstractionAdditiveExpression;
import fr.umlv.symphonie.data.formula.node.AUnaryMultiplicativeExpression;
import fr.umlv.symphonie.data.formula.node.EOF;
import fr.umlv.symphonie.data.formula.node.Node;
import fr.umlv.symphonie.data.formula.node.Start;
import fr.umlv.symphonie.data.formula.node.TAdditionOperator;
import fr.umlv.symphonie.data.formula.node.TBlanks;
import fr.umlv.symphonie.data.formula.node.TBlockEnd;
import fr.umlv.symphonie.data.formula.node.TBlockPrefix;
import fr.umlv.symphonie.data.formula.node.TBlockStart;
import fr.umlv.symphonie.data.formula.node.TBooleanLiteral;
import fr.umlv.symphonie.data.formula.node.TDivisionOperator;
import fr.umlv.symphonie.data.formula.node.TDoubleLiteral;
import fr.umlv.symphonie.data.formula.node.TEquals;
import fr.umlv.symphonie.data.formula.node.TFuncId;
import fr.umlv.symphonie.data.formula.node.TGreaterThan;
import fr.umlv.symphonie.data.formula.node.TGreaterThanOrEquals;
import fr.umlv.symphonie.data.formula.node.TIdSeparator;
import fr.umlv.symphonie.data.formula.node.TIdentifier;
import fr.umlv.symphonie.data.formula.node.TIntegerLiteral;
import fr.umlv.symphonie.data.formula.node.TLeftParenthesis;
import fr.umlv.symphonie.data.formula.node.TLessThan;
import fr.umlv.symphonie.data.formula.node.TLessThanOrEquals;
import fr.umlv.symphonie.data.formula.node.TLogicalAndOperator;
import fr.umlv.symphonie.data.formula.node.TLogicalOrOperator;
import fr.umlv.symphonie.data.formula.node.TModulusOperator;
import fr.umlv.symphonie.data.formula.node.TMultiplicationOperator;
import fr.umlv.symphonie.data.formula.node.TNotEquals;
import fr.umlv.symphonie.data.formula.node.TRightParenthesis;
import fr.umlv.symphonie.data.formula.node.TSubstractionOperator;

public class AnalysisAdapter implements Analysis {

  private Hashtable in;
  private Hashtable out;

  public Object getIn(Node node) {
    if (in == null) {
      return null;
    }

    return in.get(node);
  }

  public void setIn(Node node, Object in) {
    if (this.in == null) {
      this.in = new Hashtable(1);
    }

    if (in != null) {
      this.in.put(node, in);
    } else {
      this.in.remove(node);
    }
  }

  public Object getOut(Node node) {
    if (out == null) {
      return null;
    }

    return out.get(node);
  }

  public void setOut(Node node, Object out) {
    if (this.out == null) {
      this.out = new Hashtable(1);
    }

    if (out != null) {
      this.out.put(node, out);
    } else {
      this.out.remove(node);
    }
  }

  public void caseStart(Start node) {
    defaultCase(node);
  }

  public void caseANumericExpression(ANumericExpression node) {
    defaultCase(node);
  }

  public void caseABooleanExpression(ABooleanExpression node) {
    defaultCase(node);
  }

  public void caseAMultiplicativeAdditiveExpression(
      AMultiplicativeAdditiveExpression node) {
    defaultCase(node);
  }

  public void caseAAdditionAdditiveExpression(AAdditionAdditiveExpression node) {
    defaultCase(node);
  }

  public void caseASubstractionAdditiveExpression(
      ASubstractionAdditiveExpression node) {
    defaultCase(node);
  }

  public void caseAUnaryMultiplicativeExpression(
      AUnaryMultiplicativeExpression node) {
    defaultCase(node);
  }

  public void caseAMultiplicationMultiplicativeExpression(
      AMultiplicationMultiplicativeExpression node) {
    defaultCase(node);
  }

  public void caseADivisionMultiplicativeExpression(
      ADivisionMultiplicativeExpression node) {
    defaultCase(node);
  }

  public void caseAModulusMultiplicativeExpression(
      AModulusMultiplicativeExpression node) {
    defaultCase(node);
  }

  public void caseANumericUnaryExpression(ANumericUnaryExpression node) {
    defaultCase(node);
  }

  public void caseAMinusUnaryExpression(AMinusUnaryExpression node) {
    defaultCase(node);
  }

  public void caseALiteralNumericExpression(ALiteralNumericExpression node) {
    defaultCase(node);
  }

  public void caseAEvaluatedNumericExpression(AEvaluatedNumericExpression node) {
    defaultCase(node);
  }

  public void caseAParentheticNumericExpression(
      AParentheticNumericExpression node) {
    defaultCase(node);
  }

  public void caseAIntegerLiteralExpression(AIntegerLiteralExpression node) {
    defaultCase(node);
  }

  public void caseADoubleLiteralExpression(ADoubleLiteralExpression node) {
    defaultCase(node);
  }

  public void caseAFunctionEvaluatedExpression(AFunctionEvaluatedExpression node) {
    defaultCase(node);
  }

  public void caseACellEvaluatedExpression(ACellEvaluatedExpression node) {
    defaultCase(node);
  }

  public void caseADataBlockExpression(ADataBlockExpression node) {
    defaultCase(node);
  }

  public void caseACellBlockExpression(ACellBlockExpression node) {
    defaultCase(node);
  }

  public void caseAIdentifiers(AIdentifiers node) {
    defaultCase(node);
  }

  public void caseASeparatorSuffixedId(ASeparatorSuffixedId node) {
    defaultCase(node);
  }

  public void caseALogicalAndLogicalOrExpression(
      ALogicalAndLogicalOrExpression node) {
    defaultCase(node);
  }

  public void caseALogicalOrLogicalOrExpression(
      ALogicalOrLogicalOrExpression node) {
    defaultCase(node);
  }

  public void caseAComparativeLogicalAndExpression(
      AComparativeLogicalAndExpression node) {
    defaultCase(node);
  }

  public void caseALogicalAndLogicalAndExpression(
      ALogicalAndLogicalAndExpression node) {
    defaultCase(node);
  }

  public void caseAEqualityComparativeExpression(
      AEqualityComparativeExpression node) {
    defaultCase(node);
  }

  public void caseARelationalComparativeExpression(
      ARelationalComparativeExpression node) {
    defaultCase(node);
  }

  public void caseALiteralComparativeExpression(
      ALiteralComparativeExpression node) {
    defaultCase(node);
  }

  public void caseAParenthethicComparativeExpression(
      AParenthethicComparativeExpression node) {
    defaultCase(node);
  }

  public void caseAEqualsEqualityExpression(AEqualsEqualityExpression node) {
    defaultCase(node);
  }

  public void caseANotEqualsEqualityExpression(ANotEqualsEqualityExpression node) {
    defaultCase(node);
  }

  public void caseALessThanRelationalExpression(
      ALessThanRelationalExpression node) {
    defaultCase(node);
  }

  public void caseALessThanOrEqualsRelationalExpression(
      ALessThanOrEqualsRelationalExpression node) {
    defaultCase(node);
  }

  public void caseAGreaterThanRelationalExpression(
      AGreaterThanRelationalExpression node) {
    defaultCase(node);
  }

  public void caseAGreaterThanOrEqualsRelationalExpression(
      AGreaterThanOrEqualsRelationalExpression node) {
    defaultCase(node);
  }

  public void caseTBlockPrefix(TBlockPrefix node) {
    defaultCase(node);
  }

  public void caseTBlockStart(TBlockStart node) {
    defaultCase(node);
  }

  public void caseTBlockEnd(TBlockEnd node) {
    defaultCase(node);
  }

  public void caseTIdentifier(TIdentifier node) {
    defaultCase(node);
  }

  public void caseTIdSeparator(TIdSeparator node) {
    defaultCase(node);
  }

  public void caseTBlanks(TBlanks node) {
    defaultCase(node);
  }

  public void caseTIntegerLiteral(TIntegerLiteral node) {
    defaultCase(node);
  }

  public void caseTDoubleLiteral(TDoubleLiteral node) {
    defaultCase(node);
  }

  public void caseTBooleanLiteral(TBooleanLiteral node) {
    defaultCase(node);
  }

  public void caseTLeftParenthesis(TLeftParenthesis node) {
    defaultCase(node);
  }

  public void caseTRightParenthesis(TRightParenthesis node) {
    defaultCase(node);
  }

  public void caseTMultiplicationOperator(TMultiplicationOperator node) {
    defaultCase(node);
  }

  public void caseTDivisionOperator(TDivisionOperator node) {
    defaultCase(node);
  }

  public void caseTModulusOperator(TModulusOperator node) {
    defaultCase(node);
  }

  public void caseTAdditionOperator(TAdditionOperator node) {
    defaultCase(node);
  }

  public void caseTSubstractionOperator(TSubstractionOperator node) {
    defaultCase(node);
  }

  public void caseTEquals(TEquals node) {
    defaultCase(node);
  }

  public void caseTNotEquals(TNotEquals node) {
    defaultCase(node);
  }

  public void caseTLessThan(TLessThan node) {
    defaultCase(node);
  }

  public void caseTLessThanOrEquals(TLessThanOrEquals node) {
    defaultCase(node);
  }

  public void caseTGreaterThan(TGreaterThan node) {
    defaultCase(node);
  }

  public void caseTGreaterThanOrEquals(TGreaterThanOrEquals node) {
    defaultCase(node);
  }

  public void caseTLogicalAndOperator(TLogicalAndOperator node) {
    defaultCase(node);
  }

  public void caseTLogicalOrOperator(TLogicalOrOperator node) {
    defaultCase(node);
  }

  public void caseTFuncId(TFuncId node) {
    defaultCase(node);
  }

  public void caseEOF(EOF node) {
    defaultCase(node);
  }

  public void defaultCase(Node node) {
  }
}
